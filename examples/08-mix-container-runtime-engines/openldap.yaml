# OpenLDAP server — runs with the DEFAULT container runtime (not Reaper).
#
# This demonstrates mixed runtime engines in the same cluster: a standard
# containerized service alongside Reaper workloads that consume it.
#
# Three resources:
#   1. ConfigMap with bootstrap LDIF (users and groups)
#   2. Deployment with osixia/openldap + ldap-seeder sidecar
#   3. Service (Reaper pods resolve it via Kubernetes DNS with REAPER_DNS_MODE=kubernetes)
#
# The main container runs OpenLDAP. A sidecar container waits for LDAP
# to be ready, then loads the custom LDIF with ldapadd -c (idempotent).
# This avoids osixia's fragile bootstrap mechanism (status 68 failures).
#
# Prerequisites:
#   - Run setup.sh first (creates cluster and labels nodes)
#
# Usage:
#   kubectl apply -f openldap.yaml
#   kubectl rollout status deployment/openldap --timeout=120s
#   kubectl exec deploy/openldap -c openldap -- ldapsearch -x -H ldap://localhost \
#     -b "dc=reaper,dc=local" "(objectClass=posixAccount)" uid uidNumber

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: openldap-bootstrap-ldif
data:
  bootstrap.ldif: |
    dn: dc=reaper,dc=local
    objectClass: top
    objectClass: dcObject
    objectClass: organization
    dc: reaper
    o: Reaper

    dn: ou=users,dc=reaper,dc=local
    objectClass: organizationalUnit
    ou: users

    dn: ou=groups,dc=reaper,dc=local
    objectClass: organizationalUnit
    ou: groups

    dn: cn=ldapusr,ou=groups,dc=reaper,dc=local
    objectClass: posixGroup
    cn: ldapusr
    gidNumber: 5000
    memberUid: user1
    memberUid: user2
    memberUid: user3
    memberUid: user4
    memberUid: user5

    dn: uid=user1,ou=users,dc=reaper,dc=local
    objectClass: inetOrgPerson
    objectClass: posixAccount
    objectClass: shadowAccount
    uid: user1
    sn: One
    givenName: User
    cn: User One
    displayName: User One
    uidNumber: 10001
    gidNumber: 5000
    userPassword: password1
    loginShell: /bin/bash
    homeDirectory: /home/user1

    dn: uid=user2,ou=users,dc=reaper,dc=local
    objectClass: inetOrgPerson
    objectClass: posixAccount
    objectClass: shadowAccount
    uid: user2
    sn: Two
    givenName: User
    cn: User Two
    displayName: User Two
    uidNumber: 10002
    gidNumber: 5000
    userPassword: password2
    loginShell: /bin/bash
    homeDirectory: /home/user2

    dn: uid=user3,ou=users,dc=reaper,dc=local
    objectClass: inetOrgPerson
    objectClass: posixAccount
    objectClass: shadowAccount
    uid: user3
    sn: Three
    givenName: User
    cn: User Three
    displayName: User Three
    uidNumber: 10003
    gidNumber: 5000
    userPassword: password3
    loginShell: /bin/bash
    homeDirectory: /home/user3

    dn: uid=user4,ou=users,dc=reaper,dc=local
    objectClass: inetOrgPerson
    objectClass: posixAccount
    objectClass: shadowAccount
    uid: user4
    sn: Four
    givenName: User
    cn: User Four
    displayName: User Four
    uidNumber: 10004
    gidNumber: 5000
    userPassword: password4
    loginShell: /bin/bash
    homeDirectory: /home/user4

    dn: uid=user5,ou=users,dc=reaper,dc=local
    objectClass: inetOrgPerson
    objectClass: posixAccount
    objectClass: shadowAccount
    uid: user5
    sn: Five
    givenName: User
    cn: User Five
    displayName: User Five
    uidNumber: 10005
    gidNumber: 5000
    userPassword: password5
    loginShell: /bin/bash
    homeDirectory: /home/user5

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openldap
  labels:
    app: openldap
spec:
  replicas: 1
  selector:
    matchLabels:
      app: openldap
  template:
    metadata:
      labels:
        app: openldap
    spec:
      # No runtimeClassName — uses default containerd/runc runtime
      nodeSelector:
        role: login
      containers:
        - name: openldap
          image: osixia/openldap:1.5.0
          env:
            - name: LDAP_ORGANISATION
              value: "Reaper"
            - name: LDAP_DOMAIN
              value: "reaper.local"
            - name: LDAP_ADMIN_PASSWORD
              value: "adminpassword"
          ports:
            - containerPort: 389
              name: ldap

        # Sidecar: waits for LDAP, then seeds users via ldapadd.
        # Uses -c (continue on error) so re-runs are idempotent.
        - name: ldap-seeder
          image: osixia/openldap:1.5.0
          command: ["/bin/bash", "-c"]
          args:
            - |
              echo "Waiting for OpenLDAP to be ready..."
              until ldapsearch -x -H ldap://localhost -b "" -s base namingContexts >/dev/null 2>&1; do
                sleep 2
              done
              echo "OpenLDAP is ready. Loading bootstrap LDIF..."

              ldapadd -x -H ldap://localhost \
                -D "cn=admin,dc=reaper,dc=local" \
                -w adminpassword \
                -c \
                -f /ldifs/bootstrap.ldif

              RESULT=$?
              if [ $RESULT -eq 0 ]; then
                echo "LDIF loaded successfully."
              else
                echo "ldapadd exited with $RESULT (non-zero may be OK with -c if entries already exist)."
              fi

              # Verify (authenticated — osixia ACLs block anonymous reads)
              echo ""
              echo "=== LDAP Users ==="
              ldapsearch -x -H ldap://localhost \
                -D "cn=admin,dc=reaper,dc=local" -w adminpassword \
                -b "dc=reaper,dc=local" \
                "(objectClass=posixAccount)" uid uidNumber gidNumber 2>/dev/null \
                | grep -E "^(dn:|uid:|uidNumber:|gidNumber:|$)"
              echo ""
              echo "Seeder done — sleeping."
              exec sleep infinity
          volumeMounts:
            - name: bootstrap-ldif
              mountPath: /ldifs
              readOnly: true
      volumes:
        - name: bootstrap-ldif
          configMap:
            name: openldap-bootstrap-ldif

---
apiVersion: v1
kind: Service
metadata:
  name: openldap
  labels:
    app: openldap
spec:
  type: ClusterIP
  # Reaper workloads resolve this service via Kubernetes DNS when
  # REAPER_DNS_MODE=kubernetes (the default for Ansible-deployed clusters).
  # The kubelet-prepared resolv.conf is written into the overlay, pointing
  # to CoreDNS for service name resolution.
  selector:
    app: openldap
  ports:
    - port: 389
      targetPort: 389
      protocol: TCP
      name: ldap
